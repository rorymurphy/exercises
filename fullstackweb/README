Assumptions
1.	Building in Docker as per instructions, but this would not be recommended for a production application at this time due to the way Docker has to run with admin privileges leaving open the possibility that, if a vulnerability is found in Docker that allows code to break out of the sandbox, it would be executing as root on the host system.
2.	Installing all components in a single Docker container, although this is unlikely in practice.
3.	Designing web pages to be primarily server-side rendered, since that has advantages for SEO and this is a product page example.  Could easily use a javascript MVC/MVVM framework to render the pages, but search engines do not always parse the dynamically rendered content correctly.
4.	I am not a designer

Software
1.	Ubuntu 13.10 x64 running Docker – selected per recommended OSes, since an LTS version was not an option I figured I might as well go with the latest.
2.	Python 2.7 – selected rather than the 3.X series because there is an officially supported Ubuntu package and because there are some number of packages that are still not compatible with 3.X and, prior to starting the exercise, I was not certain whether I might need these.
3.	Nginx + uWSGI – Chose nginx for its highly efficient design, ease of configuration, and substantial support base that ensures it will be maintainable for the foreseeable future.  While I have not tested this with Python, in other languages I have also found that using a process-per-worker model typically puts a huge premium on memory – often memory would be depleted while CPU was at 25-30% utilization.  Using a multi-threaded server in conjunction with nginx is typically much more efficient, since it eliminates the overhead of loading all the shared libraries into memory for each process.
4.	I selected the Django framework, as it is the leading Python web framework, provides a lot of auto-generated boilerplate functionality to get up and running faster, and has a large ecosystem of libraries.
5.	I waffled as to whether to use a MySQL back-end or SQLite.  For a production setting, something more enterprise strength, whether it be MySQL, Postgres, MariaDB, or a commercial product would be in order.  Changing from one to the other is simple, though, and SQLite was more than sufficient for the scope of the requirements while being lighter-weight, it was a better fit for an initial version in my resource constrained VM.
6.	For search functionality, I selected elasticsearch for its reliability, scalability and performance, as well as its schema-less design, which allows the models being indexed to evolve without requiring any updates to a static schema for search functionality.  While a simpler solution using existing components might have sufficed for a prototype (e.g. a text search against the DB or even a client-side search in javascript, given the limited number of items), neither of these would produce as good of results, scale as well, or generally be suitable for production use.
7.	